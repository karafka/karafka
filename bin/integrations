#!/usr/bin/env ruby

# Runner to run integration specs in parallel

# Part of integration specs run pristine without bundler.
# If we would run bundle exec when running this code, bundler would inject its own context
# into them, messing things up heavily
raise 'This code needs to be executed WITHOUT bundle exec' if Kernel.const_defined?(:Bundler)

require 'open3'
require 'fileutils'
require 'pathname'

ROOT_PATH = Pathname.new(File.expand_path(File.join(File.dirname(__FILE__), '../')))

# Raised from the parent process if any of the integration tests fails
IntegrationTestError = Class.new(StandardError)

# How many child processes with integration specs do we want to run in parallel
# When the value is high, there's a problem with thread allocation on Github
CONCURRENCY = 4

# Abstraction around a single test scenario execution process
class Scenario
  # How long a scenario can run before we kill it
  # This is a fail-safe just in case something would hang
  MAX_RUN_TIME = 60 * 5

  # There are rare cases where Karafka may force shutdown for some of the integration cases
  # This includes exactly those
  EXIT_CODES = {
    default: [0],
    'consumption/worker_critical_error_behaviour.rb' => [0, 2].freeze,
    'shutdown/on_hanging_jobs_and_a_shutdown.rb' => [2].freeze,
    'shutdown/on_hanging_on_shutdown_job_and_a_shutdown.rb' => [2].freeze,
    'shutdown/on_hanging_poll_and_shutdown.rb' => [2].freeze
  }.freeze

  # There are specs where we do not want to inject helpers or bundler as we run inline bundler
  # to check some specific gems combinations, etc.
  # In cases like this we need to run in a pristine mode
  PRISTINE_RUNES = %w[
    rails/rails5_integration.rb
    rails/rails6_integration.rb
    rails/rails7_integration.rb
  ]

  private_constant :MAX_RUN_TIME, :EXIT_CODES, :PRISTINE_RUNES

  # Creates scenario instance and runs in the background process
  #
  # @param path [String] path to the scenarios file
  def initialize(path)
    FileUtils.mkdir_p('tmp')

    if PRISTINE_RUNES.any? { |pristine_file| path.end_with?(pristine_file) }
      # We need to run it that way as we cannot pass bundler context to be able to run inline
      # bundler mode. We cannot wrap it around directly as it would not work in the popen3
      #
      # We enter the tmp directory because of a bug in bundler: when there is a plugin defined
      # for a bundler in the directory we're in, despite being in an inline mode it will still
      # be used and we do not want that
      require 'securerandom'
      ra = SecureRandom.uuid
      FileUtils.mkdir_p("tmp/#{ra}")
      cmd = "cd tmp/#{ra} && PRISTINE_MODE=true ruby -r ../../spec/integrations_helper.rb #{path}"
      @stdin, @stdout, @stderr, @wait_thr = Open3.popen3(cmd)
    else
      cmd = "bundle exec ruby -r ./spec/integrations_helper.rb #{path}"
      @stdin, @stdout, @stderr, @wait_thr = Open3.popen3(cmd)
    end

    @path = path
    @started_at = current_time
    # Last 1024 characters from stdout
    @stdout_tail = ''
  end

  # @return [String] integration spec name
  def name
    @path.gsub("#{ROOT_PATH}/spec/integrations/", '')
  end

  # @return [Boolean] did this scenario finished or is it still running
  def finished?
    # If the thread is running too long, kill it
    if current_time - @started_at > MAX_RUN_TIME
      @wait_thr.kill
      Process.kill('TERM', pid)
    end

    # We read it so it won't grow as we use our default logger that prints to both test.log and
    # to stdout. Otherwise after reaching the buffer size, it would hang
    buffer = ''
    @stdout.read_nonblock(10_240, buffer, exception: false)
    @stdout_tail << buffer
    @stdout_tail = @stdout_tail[-10_024..-1] || @stdout_tail

    !@wait_thr.alive?
  end

  # @return [Integer] pid of the process of this scenario
  def pid
    @wait_thr.pid
  end

  # @return [Integer] exit code of the process running given scenario
  def exit_code
    # There may be no exit status if we killed the thread
    @wait_thr.value&.exitstatus || 123
  end

  # @return [Boolean] did this scenario finish successfully or not
  def success?
    expected_exit_codes = EXIT_CODES[name] || EXIT_CODES[:default]

    expected_exit_codes.include?(exit_code)
  end

  # Prints a status report when scenario is finished and stdout if it failed
  def report
    result = success? ? "\e[#{32}m#{'OK'}\e[0m" : "\e[#{31}m#{'FAILED'}\e[0m"

    puts "#{result} #{name}"

    unless success?
      puts "Exit code: #{exit_code}"
      puts @stdout_tail
      puts @stderr.read
    end
  end

  private

  # @return [Float] current machine time
  def current_time
    Process.clock_gettime(Process::CLOCK_MONOTONIC)
  end
end

# Simple array to keep track of active integration processes thread running with info on which
# test scenario is running
active_scenarios = []

# Finished runners
finished_scenarios = []

# Waits for any of the processes to be finished and tracks exit codes
#
# @param active_scenarios [Array] active runners
# @param finished_scenarios [Hash] finished forks exit codes
def wait_and_track(active_scenarios, finished_scenarios)
  exited = active_scenarios.find(&:finished?)

  if exited
    scenario = active_scenarios.delete(exited)

    scenario.report

    finished_scenarios << scenario
  else
    Thread.pass
  end
end

# Load all the specs
specs = Dir[ROOT_PATH.join('spec/integrations/**/*.rb')]

# If filters is provided, apply
# Allows to provide several filters one after another and applies all of them
ARGV.each do |filter|
  specs.delete_if { |name| !name.include?(filter) }
end

raise ArgumentError, "No integration specs with filters: #{ARGV.join(', ')}" if specs.empty?

# Randomize order
seed = (ENV['SEED'] || rand(0..10_000)).to_i

puts "Random seed: #{seed}"

specs.shuffle(random: Random.new(seed)).each do |integration_test|
  scenario = Scenario.new(integration_test)

  active_scenarios << scenario

  wait_and_track(active_scenarios, finished_scenarios) until active_scenarios.size < CONCURRENCY
end

wait_and_track(active_scenarios, finished_scenarios) while !active_scenarios.empty?

# Fail all if any of the tests does not have expected exit code
raise IntegrationTestError unless finished_scenarios.all?(&:success?)
