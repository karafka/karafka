#!/usr/bin/env ruby

# Runner to run integration specs in parallel

# Raised from the parent process if any of the integration tests fails
IntegrationTestError = Class.new(StandardError)

root_path = File.expand_path(
  File.join(
    File.dirname(__FILE__),
    '../'
  )
)

root_path = Pathname.new(root_path)

# We require it here, so when forked, all those things are already in the child processes
require root_path.join('spec/integrations_helper.rb')

# How many child processes with integration specs do we want to run in parallel
CONCURRENCY = 3

# Simple hash to keep track of active integration forks running with info on which test scenario
# is running
pids = {}

# Test scenarios processes exit codes
exits = {}

# Waits for any of the processes to be finished and tracks exit codes
#
# @param pids [Hash] active forks pids
# @param exits [Hash] finished forks exit codes
def wait_and_track(pids, exits)
  integration_test = pids.delete Process.wait

  exits[integration_test] = $CHILD_STATUS.exitstatus
end

# Run particular spec or all
specs = ARGV[0] || 'spec/integrations/**/*.rb'

Dir[root_path.join(specs)].each do |integration_test|
    pid = fork do
      require integration_test
    end

    pids[pid] = integration_test

  wait_and_track(pids, exits) if pids.size >= CONCURRENCY
end

wait_and_track(pids, exits) while !pids.empty?


puts

exits.each do |integration_test, exit_code|
  result = exit_code.zero? ? 'OK' : 'FAILED'
  test_name = integration_test.gsub("#{root_path}/spec/integrations/", '')
  puts "#{test_name} - #{result}"
end

puts

# Fail all if any test failed
raise IntegrationTestError unless exits.values.all?(&:zero?)
