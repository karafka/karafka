#!/usr/bin/env ruby

# Runner to run integration specs in parallel

require 'open3'

ROOT_PATH = Pathname.new(File.expand_path(File.join(File.dirname(__FILE__), '../')))
require ROOT_PATH.join('spec/integrations_helper.rb')

# Raised from the parent process if any of the integration tests fails
IntegrationTestError = Class.new(StandardError)

# There are rare cases where Karafka may force shutdown for some of the integration cases
# This includes exactly those
EXIT_CODES = {
  default: [0],
  'worker_critical_error_behaviour.rb' => [0, 2].freeze,
  'shutdown/on_hanging_jobs_and_a_shutdown.rb' => [2].freeze,
  'shutdown/on_hanging_on_shutdown_job_and_a_shutdown.rb' => [2].freeze,
  'shutdown/on_hanging_poll_and_shutdown.rb' => [2].freeze
}.freeze

# How many child processes with integration specs do we want to run in parallel
# When the value is high, there's a problem with thread allocation on Github
CONCURRENCY = 5

# Abstraction around a single test scenario execution process
class Scenario
  # Creates scenario instance and runs in the background process
  #
  # @param path [String] path to the scenarion file
  def initialize(path)
    @path = path
    @stdin, @stdout, @stderr, @wait_thr = Open3.popen3("bundle exec ruby #{path}")
  end

  # @return [String] integration spec name
  def name
    @path.gsub("#{ROOT_PATH}/spec/integrations/", '')
  end

  # @return [Boolean] did this scenario finished or is it still running
  def finished?
    !@wait_thr.alive?
  end

  # @return [Integer] pid of the process of this scenario
  def pid
    @wait_thr.pid
  end

  # @return [Integer] exit code of the process running given scenario
  def exit_code
    @wait_thr.value.exitstatus
  end

  # @return [Boolean] did this scenario finish successfully or not
  def success?
    expected_exit_codes = EXIT_CODES[name] || EXIT_CODES[:default]

    expected_exit_codes.include?(exit_code)
  end

  # Prints a status report when scenario is finished and stdout if it failed
  def report
    result = success? ? "\e[#{32}m#{'OK'}\e[0m" : "\e[#{31}m#{'FAILED'}\e[0m"

    puts "#{result} #{name}"
    puts @stdout.read unless success?
    puts @stderr.read unless success?
  end
end

# Simple array to keep track of active integration processes thread running with info on which
# test scenario is running
active_scenarios = []

# Finished runners
finished_scenarios = []

# Waits for any of the processes to be finished and tracks exit codes
#
# @param active_scenarios [Array] active runners
# @param finished_scenarios [Hash] finished forks exit codes
def wait_and_track(active_scenarios, finished_scenarios)
  exited = active_scenarios.find(&:finished?)

  if exited
    scenario = active_scenarios.delete(exited)

    scenario.report

    finished_scenarios << scenario
  else
    Thread.pass
  end
end

# Run particular spec or all
specs = ARGV[0] || 'spec/integrations/**/*.rb'

# Randomize order
Dir[ROOT_PATH.join(specs)].shuffle.each do |integration_test|
  scenario = Scenario.new(integration_test)

  active_scenarios << scenario

  wait_and_track(active_scenarios, finished_scenarios) until active_scenarios.size < CONCURRENCY
end

wait_and_track(active_scenarios, finished_scenarios) while !active_scenarios.empty?

# Fail all if any of the tests does not have expected exit code
raise IntegrationTestError unless finished_scenarios.all?(&:success?)
